# 2주차 - 코딩 테스트

## 문제 이름 : 뒷 큰 수 찾기 (154539)

## 가장 어려웠던 문제
#### 문제 설명
정수로 이루어진 배열 `numbers`가 있습니다. 배열의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다. 정수 배열 `numbers`가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 `solution` 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.

#### 제한사항
- 4 ≤ numbers의 길이 ≤ 1,000,000
- 1 ≤ numbers[i] ≤ 1,000,000

#### 입출력 예
| numbers                | result                |
|------------------------|-----------------------|
| [2, 3, 3, 5]           | [3, 5, 5, -1]         |
| [9, 1, 5, 3, 6, 2]     | [-1, 5, 6, 6, -1, -1] |

#### 입출력 예 설명
- **입출력 예 #1**  
  2의 뒷 큰수는 3입니다. 첫 번째 3의 뒷 큰수는 5입니다. 두 번째 3 또한 마찬가지입니다. 5는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [3, 5, 5, -1]이 됩니다.

- **입출력 예 #2**  
  9는 뒷 큰수가 없으므로 -1입니다. 1의 뒷 큰수는 5이며, 5와 3의 뒷 큰수는 6입니다. 6과 2는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [-1, 5, 6, 6, -1, -1]이 됩니다.

## 코드

```kotlin
import java.util.ArrayDeque

class Solution {
    fun solution(numbers: IntArray): IntArray {
        
        val len = numbers.size
        val answer = IntArray(len)
        val stack = ArrayDeque<Int>()

        for (i in numbers.indices) {
            while (stack.isNotEmpty() && numbers[stack.peekLast()] < numbers[i]) {
                answer[stack.removeLast()] = numbers[i]
            }
            stack.addLast(i)
        }

        while (stack.isNotEmpty()) {
            answer[stack.removeLast()] = -1
        }

        return answer
    }
}
```

## 문제 풀이 도출 과정
1. **문제 분석**
    - 주어진 numbers를 순회하면서 현재 위치보다 뒤에 있는 수를 확인한다.
    - 현재 위치보다 뒤에 있는 수 중에 현 위치의 수보다 가장 가까운 수를 answer에 넣는다.
    - 그러기 위해서는 현재 위치의 index 값을 확인한다.

2. **아이디어**
    - 스택 구조로 문제를 확인할 수 있을 것이라 생각한다.
    - 현재 위치에서 뒤에 있는 숫자를 확인하는 것이 아닌, 현재 숫자를 기점으로 앞에 숫자들을 비교하는 방식을 사용한다.
    - 스택의 구조를 활용하여 큰 숫자를 찾지 못한 수들의 index 값을 기억하고 현재 숫자와 비교하여 이 숫자가 클 경우 숫자를 기입한다.

3. **구현 방법**
    - 배열을 순회하면서 각 숫자에 대해 뒷 큰수를 찾는다.
    - 스택을 사용하여 아직 뒷 큰수를 찾지 못한 인덱스를 저장하고, 현재 숫자가 스택의 마지막 인덱스가 가리키는 숫자보다 크면, 해당 인덱스의 결과를 현재 숫자로 대체한다.
    - 모든 숫자를 순회한 후, 스택에 남아 있는 인덱스들에 대해서는 뒷 큰수가 없으므로 -1을 기입한다.

4. **문제점과 해결 방법**
    - 문제에 나와있는 대로 stack을 사용하여 현재 위치를 기반으로 뒤에 있는 숫자들을 순회하려고 하였으나, 그러면 시간 복잡도가 커지는 것을 확인했다.
    - Deque라는 기능을 발견하였고, 문제 접근 방식을 바꿔 문제를 해결하였다.
  
### 소감
문제 접근 방식을 현재 위치를 중점으로 뒤에 있는 수들과 비교하는 방식으로 하니 시간 복잡도가 많이 들어 애를 먹었다.<p>
다른 문제들에 비해 시간이 많이 들었지만, Deque라는 새로운 방식을 알게되어 많은 공부가 되었다.


## 코딩테스트 풀이 인증
#### 연동 github
<img width="1272" alt="image" src="https://github.com/user-attachments/assets/ee958beb-33ab-44d8-925d-679a8f1ad1f4">

#### 프로그래머스 기록
<img width="1194" alt="image" src="https://github.com/user-attachments/assets/facdeb09-be33-4a43-bf6a-ec5c1ad85ed9">

